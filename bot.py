import os
from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, executor, types
import checkpoints
import asyncio

check_points = checkpoints.get_points_data()
load_dotenv()
API_TOKEN = os.getenv('BOT_TOKEN')

bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)

# –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
user_data = {}

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
default_comments = ["–¢–æ—á–Ω–æ!", "–¢—ã –æ—à–∏–±—Å—è, –Ω–æ –Ω–∏—á–µ–≥–æ —Å—Ç—Ä–∞—à–Ω–æ–≥–æ"]


# start command - DONE
@dp.message_handler(commands=['start'])
async def start_handler(message: types.Message):
    keyboard = types.InlineKeyboardMarkup(row_width=1)
    keyboard.add(types.InlineKeyboardButton("–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç", callback_data='bot_info'))
    print("start_command")
    sent = await message.answer(
        "–ü—Ä–∏–≤–µ—Ç, –∏ —Å –¥–Ω–µ–º —Ä–æ–∂–¥–µ–Ω–∏—è!\n\
–ü–æ–∫–∞ –≥—Ä–∞–Ω–∏—Ü—ã –∑–∞–∫—Ä—ã—Ç—ã, –∞ –ø–æ–µ–∑–¥–∞ –∏ —Å–∞–º–æ–ª–µ—Ç—ã –¥–æ –¢—É—Ä–∫—É –Ω–µ —Ö–æ–¥—è—Ç, –º—ã –ø—Ä–∏–¥—É–º–∞–ª–∏, –∫–∞–∫ –≤—Å—ë –∂–µ –¥–æ–±—Ä–∞—Ç—å—Å—è –¥–æ —Ç–µ–±—è –≤ –≥–æ—Å—Ç–∏. –ü—É—Å—Ç—å –∏ —Ç–∞–∫–∏–º, –Ω–µ–º–Ω–æ–≥–æ –≤–æ–ª—à–µ–±–Ω—ã–º, —Å–ø–æ—Å–æ–±–æ–º.\n\n\
–ú—ã –∑–Ω–∞–µ–º, —á—Ç–æ —Ç—ã –Ω–∞–≤–µ—Ä–Ω—è–∫–∞ —É–∂–µ –∏–∑—É—á–∏–ª–∞ –¢—É—Ä–∫—É –≤–¥–æ–ª—å –∏ –ø–æ–ø–µ—Ä—ë–∫,  –ü–æ—ç—Ç–æ–º—É –º—ã –Ω–µ –±—É–¥–µ–º —Ç–µ–±—è —É—á–∏—Ç—å, –∞ –ø—Ä–æ—Å—Ç–æ –ø—Ä–µ–¥–ª–æ–∂–∏–º –ø—Ä–æ–≥—É–ª—è—Ç—å—Å—è –ø–æ –Ω–∞—à–∏–º —Å–ª–µ–¥–∞–º. –ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ, —É–¥–∞–ª–æ—Å—å –ª–∏ –Ω–∞–º –Ω–∞–π—Ç–∏ —Ö–æ—Ç—å –æ–¥–∏–Ω —É–≥–æ–ª–æ–∫, –≥–¥–µ –µ—â—ë –Ω–µ —Å—Ç—É–ø–∞–ª–∞ —Ç–≤–æ—è –Ω–æ–≥–∞?\n\n\
–°—á–∏—Ç–∞–π, —á—Ç–æ —ç—Ç–æ—Ç –∫–≤–µ—Å—Ç ‚Äî –Ω–∞—à –±–∏–ª–µ—Ç –≤ –¢—É—Ä–∫—É, –∞ —Ç—ã ‚Äî –Ω–∞—à –ø—Ä–æ–≤–æ–¥–Ω–∏–∫. –ö–∞–∫ –µ—Å–ª–∏ –±—ã –º—ã —à–ª–∏ —Ä—è–¥–æ–º, –∞ —Ç—ã –ø–æ–∫–∞–∑—ã–≤–∞–ª–∞ –Ω–∞–º –≥–æ—Ä–æ–¥ –∏ —É–¥–∏–≤–ª—è–ª–∞—Å—å –≤–º–µ—Å—Ç–µ —Å –Ω–∞–º–∏: ¬´–û, –∞ —Ç—É—Ç —è –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –±—ã–ª–∞!¬ª",
        reply_markup=keyboard
    )


#bot_info - DONE
@dp.callback_query_handler(lambda c: c.data and c.data.startswith('bot_'))
async def show_info(callback_query: types.CallbackQuery):
    user_id = callback_query.from_user.id
    print("show info function ----", user_data)
    user_data[user_id] = {'checkpoint_index': 0, 'step_index': 0}
    print(user_data)
    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ

    await bot.answer_callback_query(callback_query.id)

    info_text = "–í—ã–±–∏—Ä–∞–π –ª—é–±–æ–π —É–¥–æ–±–Ω—ã–π –¥–ª—è —Å–µ–±—è –¥–µ–Ω—å.\n–ù–∞ –ø—Ä–æ–≥—É–ª–∫—É –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è 3-4 —á–∞—Å–∞.\n\n\
–ê –µ—â–µ –º–æ–∂–Ω–æ –≤–∑—è—Ç—å –Ω–∞—Å —Å —Å–æ–±–æ–π –æ–Ω–ª–∞–π–Ω –ø–æ –∑—É–º—É.\n\n\
–ò –æ—Ç–ø—Ä–∞–≤–ª—è–π—Å—è –Ω–∞ —Å—Ç–∞—Ä—Ç"
    keyboard = types.InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        types.InlineKeyboardButton("–ê–¥—Ä–µ—Å —Å—Ç–∞—Ä—Ç–∞", callback_data='start_address')
    )

    await bot.send_message(user_id, info_text, reply_markup=keyboard)


#start_route - DONE
@dp.callback_query_handler(lambda c: c.data and c.data.startswith('start_address'))
async def start_route(callback_query: types.CallbackQuery):
    user_id = callback_query.from_user.id

    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ


    await bot.answer_callback_query(callback_query.id)

    await show_checkpoint(user_id)


# –§—É–Ω–∫—Ü–∏–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö —à–∞–≥–æ–≤ - DONE
# –û—Ç–ø—Ä–∞–≤–∫–∞ –ª—é–±–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ - title, intro, here_text, after_story_text,  next_btn_text
async def send_message(step, user_id, cp):
    if step in cp:
        await bot.send_message(user_id, cp[step])


# DONE:–û—Ç–ø—Ä–∞–≤–∫–∞ –ª—é–±–æ–π —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –∏–∑ –ø–∞–ø–∫–∏ img - story_img_path, question_img_path, here_img_path, local_question_img_path
async def send_img(img, cp, user_id):
    img_path = cp.get(img + "_img_path")
    if img_path:
        img_path = os.path.join(BASE_DIR, "img", cp[img + "_img_path"])
        await bot.send_photo(user_id, photo=open(img_path, 'rb'))


# DONE:–û—Ç–ø—Ä–∞–≤–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ - story_img_path + story_text
async def send_story(user_id, cp):
    if "story_text" in cp:
        if "story_img_path" in cp:
            await send_img("story", cp, user_id)
        await bot.send_message(user_id, cp["story_text"])
        await asyncio.sleep(10)


# DONE:–í–æ–ø—Ä–æ—Å –ø–æ –∏—Å—Ç–æ—Ä–∏–∏ –∏–ª–∏ –ª–æ–∫–∞—Ü–∏–∏, local = "" / "local" - question + options + question_img_path
async def send_question(user_id, cp, index, local=""):
    q = "question"
    op = "options"
    if local:
        q = local + "_" + q
        op = local + "_" + op
    if q+"_intro" in cp:
        await bot.send_message(user_id, cp[q+"_intro"])
    if q in cp and op in cp:
        await asyncio.sleep(3)
        keyboard = types.InlineKeyboardMarkup()

        for i, option in enumerate(cp[op]):
            try:
                keyboard.add(types.InlineKeyboardButton(option, callback_data=f"answer_{index}_{i}_{local}"))
            except Exception as e:
                print("–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫—É", e)
        try:
            await send_img(q, cp, user_id)
            await bot.send_message(user_id, cp[q], reply_markup=keyboard)
            return True
        except Exception as e:
            print("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫–∏", e)
    elif q in cp:
        print(q, cp[q])
        try:
            await bot.send_message(user_id, cp[q])
            return False
        except Exception as e:
            print("error question without options", e)


# –ö–Ω–æ–ø–∫–∞ "–Ø –∑–¥–µ—Å—å" - DONE
async def send_here_btn(user_id, index):
    keyboard = types.InlineKeyboardMarkup()
    keyboard.add(types.InlineKeyboardButton("–Ø –∑–¥–µ—Å—å",
                                            callback_data=f"arrived_{index}"))

    await bot.send_message(user_id, "üîò", reply_markup=keyboard)


# DONE:–∫–Ω–æ–ø–∫–∞ "–ø–æ—à–ª–∏ –¥–∞–ª—å—à–µ"
async def send_next_btn(user_id, index):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–ü–æ—à–ª–∏ –¥–∞–ª—å—à–µ", callback_data=f"next_{int(index) + 1}"))
    await bot.send_message(user_id, "üëâ", reply_markup=kb)


# DONE:–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —à–∞–≥–æ–≤
async def do_step(step, user_id, cp, index):
    # –ó–∞–¥–∞–Ω–∏—è –∏ –∏—Å—Ç–æ—Ä–∏—è
    if step == "question":
        q = await send_question(user_id, cp, index)
        return q
    elif step == "local_question":
        try:
            q = await send_question(user_id, cp, index, "local")
            return q
        except Exception as e:
            print("do_step, local question", e)
    elif step == "story":
        await send_story(user_id, cp)

    # –û—Ç–ø—Ä–∞–≤–∫–∞ –ª—é–±–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ - title, intro, here_text, after_story_text, question_intro, next_btn_text
    elif step in ['title', 'intro', 'here_text', 'after_story_text', 'next_btn_text']:
        try:
            if step == "here_text":
                await asyncio.sleep(3)
            await send_message(step, user_id, cp)
        except Exception as e:
            print(e)

    # –ö–Ω–æ–ø–∫–∏
    elif step == "here_btn":
        await send_here_btn(user_id, index)
        return True
    elif step == "next_btn":
        try:
            await send_next_btn(user_id, lang)
            return True
        except Exception as e:
            print(e)

    # –æ—Ç–ø—Ä–∞–≤–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ —Å—Ç–∏–∫–µ—Ä–æ–≤
    elif step == "here_img_path":
        try:
            await send_img("here", cp, user_id)
        except Exception as e:
            print("here img", e)
    return False


# DONE:–§—É–Ω–∫—Ü–∏—è –≤—ã–±–æ—Ä–∞ –∫–ø
async def show_checkpoint(user_id):
    user = user_data[user_id]
    index = user.get('checkpoint_index', 0)
    steps = checkpoints.get_steps_orden(int(index))
    cp = check_points[index]
    stop = False
    print("show", index, steps)
    # –ò–¥–µ–º –ø–æ —à–∞–≥–∞–º –¥–æ –ø–µ—Ä–≤–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ (–∑–∞–≥–∞–¥–∫–∞, –∑–∞–¥–∞–Ω–∏–µ –∏–ª–∏ –∫–Ω–æ–ø–∫–∞)
    for i in range(len(steps)):
        step = steps[i]
        user_data[user_id]['step_index'] = i
        stop = await do_step(step, user_id, cp, index)
        if stop:
            break
    if not stop:
        await next_cp(user_id, index+1)


# DONE:–ü–µ—Ä–µ—Ö–æ–¥ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ö–ü
async def next_cp(user_id, index):
    print("next", index, len(check_points), check_points)
    if index < len(check_points):
        user_data[user_id]['checkpoint_index'] = index
        user_data[user_id]['step_index'] = 0
        await show_checkpoint(user_id)
    else:
        await bot.send_message(user_id, "üéâ –ö–≤–µ—Å—Ç –∑–∞–≤–µ—Ä—à—ë–Ω! –°–ø–∞—Å–∏–±–æ, —á—Ç–æ –ø—Ä–æ—à–ª–∏ –µ–≥–æ —Å –Ω–∞–º–∏!")


# DONE:–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ø –ó–î–ï–°–¨
@dp.callback_query_handler(lambda c: c.data.startswith("arrived_"))
async def arrived_handler(callback_query: types.CallbackQuery):
    _, index = callback_query.data.split("_")
    user_id = callback_query.from_user.id
    steps = checkpoints.get_steps_orden(int(index))
    cp = check_points[int(index)]

    # –£–¥–∞–ª—è–µ–º –∫–Ω–æ–ø–∫—É
    await bot.delete_message(callback_query.message.chat.id, callback_query.message.message_id)
    await bot.answer_callback_query(callback_query.id)
    step_i = user_data[user_id]['step_index'] + 1
    print(step_i, len(steps))
    if step_i < len(steps):
        print("no")
        for i in range(step_i, len(steps)):
            step = steps[i]
            user_data[user_id]['step_index'] = i
            stop = await do_step(step, user_id, cp, index)
            if stop:
                break
    else:
        try:
            await next_cp(user_id, int(index)+1)
        except Exception as e:
            print(e)


# DONE:–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ç–≤–µ—Ç–æ–≤
@dp.callback_query_handler(lambda c: c.data.startswith("answer_"))
async def answer_handler(callback_query: types.CallbackQuery):
    _, index, selected, local = callback_query.data.split("_")
    index = int(index)
    user_id = callback_query.from_user.id
    cp = check_points[index]
    steps = checkpoints.get_steps_orden(int(index))

    #await bot.delete_message(chat_id=callback_query.message.chat.id, message_id=callback_query.message.message_id)
    await bot.answer_callback_query(callback_query.id)
    selected = int(selected)
    ans = local + "_" + "answer" if local else "answer"
    ans_number = cp.get(ans)
    print(ans_number, ans)
    if ans_number:
        try:
            if selected == ans_number:
                await bot.send_message(user_id, default_comments[0])
            else:
                await bot.send_message(user_id, default_comments[1])
        except Exception as e:
            print("ans_number", e)
    else:
        ans_comments = ans + "_comments"
        comment = cp.get(ans_comments, {}).get(selected, {})
        print("comment", comment)
        if comment:
            try:
                await bot.send_message(user_id, comment)
            except Exception as e:
                print("comment", e)
    step_i = user_data[user_id]['step_index'] + 1
    print(step_i)
    await asyncio.sleep(3)
    if step_i < len(steps):
        for i in range(step_i, len(steps)):
            step = steps[i]
            user_data[user_id]['step_index'] = i
            stop = await do_step(step, user_id, cp, index)
            if stop:
                break
    else:
        await next_cp(user_id, int(index) + 1)


# DONE:–ü–µ—Ä–µ—Ö–æ–¥ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ö–ü
@dp.callback_query_handler(lambda c: c.data.startswith("next_"))
async def next_checkpoint(callback_query: types.CallbackQuery):
    _, index = callback_query.data.split("_")
    index = int(index)
    user_id = callback_query.from_user.id

    await bot.delete_message(chat_id=callback_query.message.chat.id, message_id=callback_query.message.message_id)
    await bot.answer_callback_query(callback_query.id)

    await next_cp(user_id, index)


if __name__ == '__main__':
    executor.start_polling(dp, skip_updates=True)
